"""Authentication utilities shared across Quote Tool views."""

from __future__ import annotations

import hashlib
import re
import secrets
from datetime import datetime, timedelta
from typing import Optional, Tuple

from flask import current_app
from sqlalchemy import func
from sqlalchemy.exc import SQLAlchemyError

from app.models import PasswordResetToken, User, db

_PASSWORD_RE = re.compile(r"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\w\s]).{14,}$")
_PHONE_DIGITS_RE = re.compile(r"\d")
_EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")


def is_valid_password(candidate: str) -> bool:
    """Return ``True`` when ``candidate`` meets complexity requirements.

    Args:
        candidate: Password submitted by the user.

    Returns:
        bool: ``True`` when the password contains a mix of uppercase, lowercase,
        numeric, and symbol characters with a minimum length of 14. Passphrases
        at least 24 characters long are accepted regardless of character mix.

    External Dependencies:
        None.
    """

    if candidate is None:
        return False
    stripped = candidate.strip()
    if len(stripped) >= 24:
        return True
    return bool(_PASSWORD_RE.match(stripped))


def is_valid_email(address: str) -> bool:
    """Return ``True`` when ``address`` looks like a valid email.

    Args:
        address: Candidate email address supplied by the caller.

    Returns:
        bool: ``True`` when ``address`` follows a simple ``local@domain``
        structure containing at least one dot in the domain.

    External Dependencies:
        None.
    """

    if not address:
        return False
    return bool(_EMAIL_RE.match(address.strip()))


def is_valid_phone(value: str) -> bool:
    """Return ``True`` when ``value`` contains at least 10 digits.

    Args:
        value: Free-form telephone number entered by the user.

    Returns:
        bool: ``True`` when the string contains at least ten numeric characters.

    External Dependencies:
        None.
    """

    if not value:
        return False
    digits = _PHONE_DIGITS_RE.findall(value)
    return len(digits) >= 10


def hash_reset_token(token: str) -> str:
    """Return the SHA-256 hash for ``token`` encoded as hexadecimal.

    Args:
        token: Plain-text reset token generated by :func:`create_reset_token`.

    Returns:
        str: Hexadecimal digest safe for storage in the database.

    External Dependencies:
        None.
    """

    return hashlib.sha256(token.encode("utf-8")).hexdigest()


def _parse_reset_rate_limit(value: str) -> Tuple[int, timedelta]:
    """Parse ``AUTH_RESET_TOKEN_RATE_LIMIT`` into a limit and duration.

    Args:
        value: Configuration string such as ``"1 per 15 minutes"``.

    Returns:
        tuple: Pair of ``(count, timedelta)`` describing how many tokens may be
        issued within the configured interval.

    External Dependencies:
        None.
    """

    default = (1, timedelta(minutes=15))
    if not value:
        return default
    parts = value.split()
    if len(parts) != 4 or parts[1].lower() != "per":
        return default
    try:
        count = int(parts[0])
        duration_value = int(parts[2])
    except ValueError:
        return default
    unit = parts[3].lower()
    if unit.startswith("minute"):
        return count, timedelta(minutes=duration_value)
    if unit.startswith("hour"):
        return count, timedelta(hours=duration_value)
    if unit.startswith("day"):
        return count, timedelta(days=duration_value)
    return default


def create_reset_token(email: str) -> Tuple[Optional[str], Optional[str]]:
    """Create a password reset token for ``email`` if allowed.

    Args:
        email: Email address associated with the user requesting a reset.

    Returns:
        tuple: ``(token, error_message)``. ``token`` contains the plaintext
        token when successful. ``error_message`` is populated when the request
        cannot be fulfilled (for example due to rate limiting or unknown user).

    External Dependencies:
        * Queries :class:`User` and :class:`PasswordResetToken` via SQLAlchemy.
    """

    if not is_valid_email(email):
        return None, "Invalid email address."

    normalised = email.strip().lower()
    user = User.query.filter_by(email=normalised).first()
    if user is None or not getattr(user, "is_active", True):
        return None, "Account is not eligible for password resets."

    limit_value = current_app.config.get("AUTH_RESET_TOKEN_RATE_LIMIT", "1 per 15 minutes")
    limit, window = _parse_reset_rate_limit(str(limit_value))
    now = datetime.utcnow()

    if limit > 0:
        try:
            recent_count = (
                db.session.query(func.count(PasswordResetToken.id))
                .filter(
                    PasswordResetToken.user_id == user.id,
                    PasswordResetToken.created_at >= now - window,
                )
                .scalar()
                or 0
            )
        except SQLAlchemyError as exc:  # pragma: no cover - defensive logging
            current_app.logger.warning(
                "Failed to enforce reset token rate limit for %s: %s", normalised, exc
            )
            recent_count = 0
        if recent_count >= limit:
            return None, "Reset already requested recently. Please wait."

    raw_token = secrets.token_urlsafe(32)
    hashed_token = hash_reset_token(raw_token)
    expiry_minutes = current_app.config.get("AUTH_RESET_TOKEN_EXPIRY_MINUTES", 60)
    try:
        expires = now + timedelta(minutes=int(expiry_minutes))
    except (TypeError, ValueError):
        expires = now + timedelta(hours=1)

    record = PasswordResetToken(
        user_id=user.id,
        token=hashed_token,
        expires_at=expires,
        created_at=now,
    )
    db.session.add(record)
    db.session.commit()
    return raw_token, None


def reset_password_with_token(token: str, password: str) -> Optional[str]:
    """Reset a user's password using ``token`` when valid.

    Args:
        token: Plain-text reset token provided by the requester.
        password: New password to assign to the account.

    Returns:
        Optional[str]: ``None`` on success or an error message explaining the
        failure condition.

    External Dependencies:
        * Queries :class:`PasswordResetToken` and :class:`User` via SQLAlchemy.
    """

    if not token:
        return "Missing reset token."
    if not is_valid_password(password):
        return "Password does not meet complexity requirements."

    hashed = hash_reset_token(token)
    reset_record = (
        PasswordResetToken.query.filter_by(token=hashed, used=False)
        .order_by(PasswordResetToken.created_at.desc())
        .first()
    )
    if reset_record is None:
        return "Invalid or expired token."
    if reset_record.expires_at < datetime.utcnow():
        return "Invalid or expired token."

    user = db.session.get(User, reset_record.user_id)
    if user is None:
        return "Account not found for reset token."

    user.set_password(password)
    reset_record.used = True
    db.session.add(user)
    db.session.add(reset_record)
    db.session.commit()
    return None


__all__ = [
    "create_reset_token",
    "hash_reset_token",
    "is_valid_email",
    "is_valid_password",
    "is_valid_phone",
    "reset_password_with_token",
]
